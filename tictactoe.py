# -*- coding: utf-8 -*-
"""TicTacToe.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AydIYznCOPLTf0zIHDNZ3hzTlJP2HivM
"""

!pip install pade

import numpy as np
import pade
from pade.misc.utility import display_message, start_loop
from pade.core.agent import Agent
from pade.acl.aid import AID
from pade.acl.messages import ACLMessage
import random
import sys

magicSquare = [2,7,6,9,5,1,4,3,8]

board = ['_' for i in range(9)]

def isWin(player):
    for i in range(9):
        for j in range(9):
            for k in range(9):
                if i!=j and j!=k and i!=k:
                    if(board[i] == player and board[j] == player and board[k] == player):
                        if(magicSquare[i] + magicSquare[j] + magicSquare[k] == 15):
                            return True
    
    return False

def isBoardFull():
    for i in range(9):
        if board[i] == '_':
            return False
      
    return True

def isHumanWin():
    
        #check for possible win move along rows
        for player in ['X','O']:
            for i in range(3):
                s = 0
                j = i*3
                if board[j] == player and board[j+1] == player:
                    s = magicSquare[j] + magicSquare[j+1]
                elif board[j] == player and board[j+2] == player:
                    s = magicSquare[j] + magicSquare[j+2]
                elif board[j+1] == player and board[j+2] == player:
                    s = magicSquare[j+1] + magicSquare[j+2]

                if s!=0:
                    pos = magicSquare.index(15-s)
                    if board[pos] == '_':
                        return pos
        #check for possible win move along column
        for player in ['X','O']:
            for i in range(3):
                s = 0

                if board[i] == player and board[i+3] == player:
                    s = magicSquare[i] + magicSquare[i+3]
                elif board[i] == player and board[i+6] == player:
                    s = magicSquare[i] + magicSquare[i+6]
                elif board[i+3] == player and board[i+6] == player:
                    s = magicSquare[i+3] + magicSquare[i+6]

                if s!=0:
                    pos = magicSquare.index(15-s)
                    if board[pos] == '_':
                        return pos        
        #check along diagonals
        for player in ['X','O']:
            s = 0
            if board[0] == player and board[4] == player:
                s = magicSquare[0] + magicSquare[4]
            elif board[0] == player and board[8] == player:
                s = magicSquare[0] + magicSquare[8]
            elif board[4] == player and board[8] == player:
                s = magicSquare[4] + magicSquare[8]

            if s!=0:
                pos = magicSquare.index(15-s)
                if board[pos] == '_':
                    return pos
        
        for player in ['X','O']:
            s = 0
            if board[2] == player and board[4] == player:
                s = magicSquare[2] + magicSquare[4]
            elif board[2] == player and board[6] == player:
                s = magicSquare[2] + magicSquare[6]
            elif board[4] == player and board[6] == player:
                s = magicSquare[4] + magicSquare[6]

            if s!=0:
                pos = magicSquare.index(15-s)
                if board[pos] == '_':
                    return pos
        
        
        #return random move from available positions if winning move not found
        availableMoves = []
        for i in range(9):
            if board[i] == '_':
                availableMoves.append(i)
        
        if len(availableMoves)!=0:
            return availableMoves[random.randint(0,len(availableMoves))]

def displayBoard():
    print('\n')
    print('\n')
    print('| ' + board[0] + ' | ' + board[1] + ' | ' + board[2]+ ' | ')
    print('| ' + board[3] + ' | ' + board[4] + ' | ' + board[5]+ ' | ')
    print('| ' + board[6] + ' | ' + board[7] + ' | ' + board[8]+ ' | ')
    print('\n')
    print('\n')

class HumanAgent(Agent):
    def __init__(self , aid, receiver_agent):
        super().__init__(aid)
        self.receiver_agent = receiver_agent
    
    def react(self, message):
        super().react(message)
        display_message(self.aid.localname, 'Message received from {}'.format(message.sender.name))
        display_message(self.aid.localname, 'Message is {}'.format(message.content))
        self.send_message()
    
    def on_start(self):
        super().on_start()
        self.send_message()
    
    def send_message(self):
        try:
            message = ACLMessage(ACLMessage.INFORM)
            message.set_protocol(ACLMessage.FIPA_REQUEST_PROTOCOL)
            message.add_receiver(self.receiver_agent)
            self.add_all_agents(message.receivers)
            pos = int(input('Enter the position you want to make a move in (1-9): '))
            
            while(board[pos-1] != '_'):
                pos = int(input('Sorry, the move is already taken here! Try another position (1-9): '))

            board[pos-1] = 'X'
            displayBoard()
            if isWin('X'):
                print('\n\t**Congratulations!!You won! **')
                sys.exit()


            if not isWin('X'):
                if not isWin('O'):
                    if isBoardFull():
                        print('\n\t** It\'s a TIE **')
                        sys.exit()



            message.set_content('Human Agent played "X"'+' at position '+str(pos))
            self.send(message)
        except:
            print("\n\t** Game Over! **")
        
        
    def add_all_agents(self, receivers):
        for receiver in receivers:
            self.agentInstance.table[receiver.localname] = receiver

class ComputerAgent(Agent):
    def __init__(self, aid):
        super().__init__(aid)

    def react(self, message):
        super().react(message)
        display_message(self.aid.localname, 'Message received from {}'.format(message.sender.name))
        display_message(self.aid.localname, 'Message is {}'.format(message.content))
        self.send_message(AID(message.sender.name))                
                    
    
    def send_message(self, receiver_agent):
        try:
            message = ACLMessage(ACLMessage.INFORM)
            message.set_protocol(ACLMessage.FIPA_REQUEST_PROTOCOL)
            message.add_receiver(receiver_agent)
            self.add_all_agents(message.receivers)

            winningMove = isHumanWin()

            board[winningMove] = 'O'
            displayBoard()

            if isWin('O'):
                print('\n\t**Oops!! Computer Agent Won! **')
                sys.exit()


            if not isWin('X'):
                if not isWin('O'):
                    if isBoardFull():
                        print('\n\t** It\'s a TIE!! **')
                        sys.exit()

            message.set_content('Computer Agent played "O" at the '+str(winningMove+1)+' position!')
            self.send(message)
        except:
            print("\n\t** Game Over!**")

    def add_all_agents(self, receivers):
        for receiver in receivers:
            self.agentInstance.table[receiver.localname] = receiver

if __name__ == '__main__':
    agents = list()
    displayBoard()
    receiver_agent_aid = AID(name='Computer Agent')
    receiverAgent = ComputerAgent(receiver_agent_aid)
    agents.append(receiverAgent)
    sender_agent = HumanAgent(AID(name='Human Agent'), receiver_agent_aid)
    agents.append(sender_agent)

    start_loop(agents)